# 객체 지향 프로그래밍 소개

## 클래스(Classes)와 객체(Objects)

**클래스**는 객체의 데이터 **속성**과 동작 (**메서드**)을 정의하는 청사진으로 작용합니다;
**객체**는 이러한 클래스의 인스턴스로, 런타임에서 생성되며 고유한 상태와 식별자를 가집니다.
동일한 클래스에서 여러 객체를 인스턴스화할 수 있으며, 해당 클래스에서 정의된 데이터 속성의 각자 인스턴스를 포함합니다. 객체의 메서드는 내부 데이터에 작용할 수 있습니다.

*캡슐화*는 클래스의 데이터와 메서드를 단일 단위로 묶어 외부 코드가 내부 표현을 직접 액세스하는 것을 방지합니다. 대신, 객체와의 상호 작용은 잘 정의된 공개 인터페이스를 통해 관리됩니다.
이 캡슐화는 *추상화*와 *정보 은닉*을 제공하여 복잡성을 줄이고 *느슨한 결합*을 촉진합니다.

객체 지향 설계에서 클래스는 응용 프로그램 도메인의 구체적인 또는 추상적인 엔티티와 일치하도록 설계할 수 있으며, *도메인 주도 설계*를 가능하게 합니다. 핵심 설계 측면은 합리적이고 직관적인 계산 및 표현 단위를 제공하는 올바른 클래스와 추상화/인터페이스 집합을 결정하는 것입니다.

## 상속(Inheritance)

상속은 새로운 클래스를 정의하여 기존 클래스의 동작을 재사용하고 확장하거나 수정하는 것을 허용합니다. 새로운 클래스를 *하위 클래스* 또는 자식 클래스라고하며, 상속받은 클래스는 *상위 클래스* 또는 부모 클래스입니다. 하위 클래스는 부모의 속성과 메서드를 상속받기 때문에 코드를 다시 작성할 필요가 없습니다. 자식 클래스는 선택적으로 새로운 속성과 동작을 추가하여 부모의 기능을 확장할 수 있습니다. 따라서 상속은 클래스 간의 계층적 관계를 설정하고 코드 재사용을 촉진합니다.

모든 메서드를 구현하지 않은 부모 클래스는 *추상*이라고하며, 실행 시점에는 인스턴스화 될 수 없습니다. 이러한 클래스는 객체 지향 프로그래밍에서 인터페이스로 사용되는 추상화를 정의합니다.


## 하위 유형 다형성: 인터페이스로서의 추상화

상속은 하위 유형 다형성을 지원하며, 여기서 하위 클래스 객체를 부모 객체 대신 사용할 수 있습니다.
즉, 함수가 부모 클래스의 인스턴스를 매개변수로 예상하는 경우 해당 하위 클래스의 인스턴스를 대신 전달할 수 있습니다. 이를 통해 특정한 일반화가 가능해집니다:
  - 공통 상위 클래스의 인스턴스인 경우에는 서로 다른 유형의 객체를 동일하게 처리할 수 있습니다.
  - (동적으로) 동작을 수정할 수 있습니다. 즉, 알고리즘에서 실행 중인 구현을 교체함으로써, 다른 하위 클래스를 사용하여 알고리즘에서 예상하는 상위 클래스의 다른 하위 클래스를 사용할 수 있습니다.

추상 클래스는 특히 인터페이스 사양으로서 편리하며, 대부분의 경우 순수한 함수 기반 인터페이스(즉, 고차 함수)보다 선호됩니다. 왜냐하면:

 - 기본 클래스는 잠재적인 구현을 직접적으로 발견할 수 있는 형식 제한을 제공합니다: 형식의 클래스 계층 구조는 즉시 가능한 옵션을 제공합니다.
 - 객체는 더 쉽게 기록 및 저장할 수 있는 표현을 갖습니다.
 - 객체는 속성을 통해 동작을 직접적으로 매개변수화할 수 있으며, 이는 `lambda` 함수나 `functools.partial`을 통한 함수 커링을 요구하는 것보다 사용자 친화적입니다.
 - 형식 관계는 명시적입니다 (`Protocol`와 같은 덕 타이핑 개념과 대조적입니다).

위의 많은 점들은 구체적인 예제를 살펴보면 명확해질 것입니다. 다음 [사례 연구](../02a-case-study-0-unstructured-script/README.md)에서 이를 확인해 보겠습니다.