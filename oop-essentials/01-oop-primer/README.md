# 객체 지향 프로그래밍 소개

## 클래스(Classes)와 객체(Objects)

**클래스**는 객체의 데이터 **속성**과 동작 (**메서드**)을 정의하는 청사진으로 사용합니다. **객체**는 이러한 클래스의 인스턴스로, 런타임에서 생성되며 고유한 상태와 식별자를 가집니다.
동일한 클래스에서 여러 객체를 인스턴스화할 수 있으며 해당 클래스에서 정의된 데이터 속성은 각각의 인스턴스를 포함합니다. 또한 객체의 메서드는 내부 데이터에 작용할 수 있습니다.

*캡슐화*는 클래스의 데이터와 메서드를 단일 단위로 묶어 외부 코드가 내부 표현을 직접 액세스하는 것을 방지합니다. 대신 객체와의 상호 작용은 공개 인터페이스로 정의해 관리합니다. 캡슐화는 *추상화*와 *정보 은닉*을 통해 코드의 복잡성을 줄이고 *느슨한 결합*을 촉진합니다.

객체 지향 설계에서 클래스는 응용 프로그램 도메인의 구체적인 또는 추상적인 엔티티와 일치하도록 설계할 수 있으며 *도메인 주도 설계*를 가능하게 합니다. 핵심은 합리적인 설계와 직관적인 표현을 제공하는 올바른 클래스와 추상화/인터페이스 집합을 만드는 것입니다.

## 상속(Inheritance)

상속은 새로운 클래스가 기존 클래스의 동작을 재사용하고 확장하거나 수정하는 것을 허용하는 개념입니다. 새로운 클래스를 *하위 클래스* 또는 자식 클래스라고하며, 상속받은 클래스는 *상위 클래스* 또는 부모 클래스라 합니다. 하위 클래스는 부모의 속성과 메서드를 상속받기 때문에 코드를 다시 작성할 필요가 없습니다. 자식 클래스는 선택적으로 새로운 속성과 동작을 추가하여 부모의 기능을 확장할 수 있습니다. 따라서 상속은 클래스 간의 계층적 관계를 설정하고 코드 재사용을 촉진합니다.

모든 메서드를 구현하지 않은 부모 클래스를 *추상* 클래스라고하며 객체 지향 프로그래밍에서 추상화된 인터페이스를 정의합니다.

## 하위 유형 다형성: 인터페이스로서의 추상화

상속은 하위 유형 다형성을 지원하며, 여기서 하위 클래스 객체를 부모 객체 대신 사용할 수 있습니다. 즉, 함수가 부모 클래스의 인스턴스를 매개변수로 예상하는 경우 해당 하위 클래스의 인스턴스를 대신 전달할 수 있습니다. 이를 통해 일반화가 가능해집니다:
  - 공통 상위 클래스의 인스턴스인 경우에는 서로 다른 유형의 객체를 동일하게 처리할 수 있습니다.
  - (동적으로) 동작을 수정할 수 있습니다. 즉, 알고리즘에서 실행 중인 구현을 교체함으로써 다른 하위 클래스를 사용하여 알고리즘에서 예상하는 상위 클래스의 다른 하위 클래스를 사용할 수 있습니다.

추상 클래스는 특히 인터페이스로서 편리하며, 대부분의 경우 순수한 함수 기반 인터페이스(즉, 고차 함수)보다 선호됩니다. 왜냐하면:
 - 기본 클래스는 잠재적인 구현을 직접적으로 발견할 수 있는 형식 제한하지만 클래스 계층 구조는 가능한 여러 옵션을 제공합니다.
 - 객체가 더 쉽게 기록 및 저장되는 표현을 갖습니다.
 - 객체는 속성을 통해 동작을 직접적으로 매개변수화할 수 있으며, 이는 `lambda` 함수나 `functools.partial`을 통한 함수를 요구하는 것보다 사용자 친화적입니다.
 - 형식 관계는 명시적입니다 (`Protocol`와 같은 덕 타이핑 개념과 대조적입니다).

위의 많은 점들은 구체적인 예제를 살펴보면 명확해질 것입니다. 다음 [사례 연구](../02a-case-study-0-unstructured-script/README.md)에서 이를 확인해 보겠습니다.